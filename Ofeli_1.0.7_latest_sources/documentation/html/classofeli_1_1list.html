<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Ofeli: ofeli::list&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ofeli.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ofeli
   &#160;<span id="projectnumber">1.0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceofeli.html">ofeli</a></li><li class="navelem"><a class="el" href="classofeli_1_1list.html">list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classofeli_1_1list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ofeli::list&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="linked__list_8hpp_source.html">linked_list.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ofeli::list&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classofeli_1_1list__coll__graph.png" border="0" usemap="#ofeli_1_1list_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="ofeli_1_1list_3_01_t_01_4_coll__map" id="ofeli_1_1list_3_01_t_01_4_coll__map">
<area shape="rect" id="node2" href="structofeli_1_1list_1_1_node.html" title="This structure implements a node of class list. It is composed by an element of type T and a pointer ..." alt="" coords="5,5,144,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator to read a const list.  <a href="classofeli_1_1list_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to modify a list.  <a href="classofeli_1_1list_1_1iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structofeli_1_1list_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure implements a node of class <em>list</em>. It is composed by an element of type <em>T</em> and a pointer on the next node.  <a href="structofeli_1_1list_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39932b3048b4ddbac43b00e7bad6a9da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39932b3048b4ddbac43b00e7bad6a9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a39932b3048b4ddbac43b00e7bad6a9da">list</a> (int mem_pool_size1)</td></tr>
<tr class="memdesc:a39932b3048b4ddbac43b00e7bad6a9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a39932b3048b4ddbac43b00e7bad6a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add13c528e17c77a568aea94adec5db71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add13c528e17c77a568aea94adec5db71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#add13c528e17c77a568aea94adec5db71">list</a> (int mem_pool_size1, int n, const T &amp;value)</td></tr>
<tr class="memdesc:add13c528e17c77a568aea94adec5db71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create a list with <em>n</em> value. <br/></td></tr>
<tr class="separator:add13c528e17c77a568aea94adec5db71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02bf0a0e738893734778313def2b557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac02bf0a0e738893734778313def2b557"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ac02bf0a0e738893734778313def2b557">list</a> (int mem_pool_size1, const T array[], int array_length)</td></tr>
<tr class="memdesc:ac02bf0a0e738893734778313def2b557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create a list from an array. <br/></td></tr>
<tr class="separator:ac02bf0a0e738893734778313def2b557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6634b04ef70d4a4a11af6974e0b2b685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6634b04ef70d4a4a11af6974e0b2b685"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a6634b04ef70d4a4a11af6974e0b2b685">list</a> (int mem_pool_size1, const <a class="el" href="classofeli_1_1list.html">list</a> &amp;copied)</td></tr>
<tr class="memdesc:a6634b04ef70d4a4a11af6974e0b2b685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a6634b04ef70d4a4a11af6974e0b2b685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093d68c35e21c0b52c12a371be58826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0093d68c35e21c0b52c12a371be58826"></a>
<a class="el" href="classofeli_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a0093d68c35e21c0b52c12a371be58826">operator=</a> (const <a class="el" href="classofeli_1_1list.html">list</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0093d68c35e21c0b52c12a371be58826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator overloading. <br/></td></tr>
<tr class="separator:a0093d68c35e21c0b52c12a371be58826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fef2e0c33ffa015c2d4e9e8f11356a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68fef2e0c33ffa015c2d4e9e8f11356a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a68fef2e0c33ffa015c2d4e9e8f11356a">~list</a> ()</td></tr>
<tr class="memdesc:a68fef2e0c33ffa015c2d4e9e8f11356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. All the elements in the list container are dropped (including the sentinel node) : their destructors are called, and then they are removed from the list container, leaving it with a size of 0. <br/></td></tr>
<tr class="separator:a68fef2e0c33ffa015c2d4e9e8f11356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4ab444619f6d412a461752ba019514"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b4ab444619f6d412a461752ba019514"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a1b4ab444619f6d412a461752ba019514">clear</a> ()</td></tr>
<tr class="memdesc:a1b4ab444619f6d412a461752ba019514"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the elements in the list container are dropped (except the sentinel node) : their destructors are called, and then they are removed from the list container, leaving it with a size of 0. <br/></td></tr>
<tr class="separator:a1b4ab444619f6d412a461752ba019514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f0567a64758636e3835ecea28a36f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f7f0567a64758636e3835ecea28a36f"></a>
<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a4f7f0567a64758636e3835ecea28a36f">begin</a> ()</td></tr>
<tr class="memdesc:a4f7f0567a64758636e3835ecea28a36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head link. <br/></td></tr>
<tr class="separator:a4f7f0567a64758636e3835ecea28a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abcaf1bc66a9c292018efa55d6250ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2abcaf1bc66a9c292018efa55d6250ff"></a>
<a class="el" href="classofeli_1_1list_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a2abcaf1bc66a9c292018efa55d6250ff">begin</a> () const </td></tr>
<tr class="memdesc:a2abcaf1bc66a9c292018efa55d6250ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head link. <br/></td></tr>
<tr class="separator:a2abcaf1bc66a9c292018efa55d6250ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c619ab7fedd643db5f3894889d91c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a8c619ab7fedd643db5f3894889d91c74">assign</a> (int n, const T &amp;value)</td></tr>
<tr class="separator:a8c619ab7fedd643db5f3894889d91c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbe8cc25a5c413924db708e47161306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a7fbe8cc25a5c413924db708e47161306">assign</a> (const T array[], int array_length)</td></tr>
<tr class="separator:a7fbe8cc25a5c413924db708e47161306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38beb590b14408cbe2e0e5d573fbf5e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38beb590b14408cbe2e0e5d573fbf5e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a38beb590b14408cbe2e0e5d573fbf5e2">pop_front</a> ()</td></tr>
<tr class="memdesc:a38beb590b14408cbe2e0e5d573fbf5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element in the <em>list</em> container, effectively reducing its size by one. <br/></td></tr>
<tr class="separator:a38beb590b14408cbe2e0e5d573fbf5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b7f6a90670e08d99e23f3377b001f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87b7f6a90670e08d99e23f3377b001f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a87b7f6a90670e08d99e23f3377b001f9">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a87b7f6a90670e08d99e23f3377b001f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the beginning of the list. <br/></td></tr>
<tr class="separator:a87b7f6a90670e08d99e23f3377b001f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ae0af886d7932bdf5a5183e2a64c91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05ae0af886d7932bdf5a5183e2a64c91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a05ae0af886d7932bdf5a5183e2a64c91">push_front</a> (const <a class="el" href="classofeli_1_1list.html">list</a> &amp;copied)</td></tr>
<tr class="memdesc:a05ae0af886d7932bdf5a5183e2a64c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts copies of list <em>copied</em> elements at the beginning of the list <em>*this</em>. <br/></td></tr>
<tr class="separator:a05ae0af886d7932bdf5a5183e2a64c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3925aa31728a510af35d3229cd00a43f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3925aa31728a510af35d3229cd00a43f"></a>
template&lt;typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a3925aa31728a510af35d3229cd00a43f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a3925aa31728a510af35d3229cd00a43f">put_away</a> (const T &amp;value, BinaryPredicate compare)</td></tr>
<tr class="memdesc:a3925aa31728a510af35d3229cd00a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts away a new element to maintain sorted list into the specified order. <br/></td></tr>
<tr class="separator:a3925aa31728a510af35d3229cd00a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0970694ba9e35222daa2ecc156f71661"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0970694ba9e35222daa2ecc156f71661"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a0970694ba9e35222daa2ecc156f71661">put_away</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a0970694ba9e35222daa2ecc156f71661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts away a new element to maintain sorted list into ascending order. <br/></td></tr>
<tr class="separator:a0970694ba9e35222daa2ecc156f71661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347778b1ef2f0530cb73403665f28caf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a347778b1ef2f0530cb73403665f28caf"></a>
<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a347778b1ef2f0530cb73403665f28caf">insert_before</a> (<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> position, const T &amp;value)</td></tr>
<tr class="memdesc:a347778b1ef2f0530cb73403665f28caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element before <em>position</em>. Returns the position of the inserted element. <br/></td></tr>
<tr class="separator:a347778b1ef2f0530cb73403665f28caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cdc246b5f3b431d18e148d3dcad54e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89cdc246b5f3b431d18e148d3dcad54e"></a>
<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a89cdc246b5f3b431d18e148d3dcad54e">insert_after</a> (<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> position, const T &amp;value)</td></tr>
<tr class="memdesc:a89cdc246b5f3b431d18e148d3dcad54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element after <em>position</em>. Returns the position of the inserted element. <br/></td></tr>
<tr class="separator:a89cdc246b5f3b431d18e148d3dcad54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae160d4ea7224becad437add3b1d594e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae160d4ea7224becad437add3b1d594e4"></a>
<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ae160d4ea7224becad437add3b1d594e4">erase</a> (<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> position)</td></tr>
<tr class="memdesc:ae160d4ea7224becad437add3b1d594e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the list container the element at <em>position</em> and returns a valid iterator, i.e. the position of the next element. <br/></td></tr>
<tr class="separator:ae160d4ea7224becad437add3b1d594e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f61ba4f2a9f7d67c4737baa9096386c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f61ba4f2a9f7d67c4737baa9096386c"></a>
<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a5f61ba4f2a9f7d67c4737baa9096386c">erase_after</a> (<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> position)</td></tr>
<tr class="memdesc:a5f61ba4f2a9f7d67c4737baa9096386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the list container the element at <em>++position</em> and returns the position. <br/></td></tr>
<tr class="separator:a5f61ba4f2a9f7d67c4737baa9096386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ebb4b33ce7f5518b78eb1e8ae3464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#af38ebb4b33ce7f5518b78eb1e8ae3464">splice_front</a> (<a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> moved)</td></tr>
<tr class="separator:af38ebb4b33ce7f5518b78eb1e8ae3464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92338c30de397c0ac7bf224280c5607e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92338c30de397c0ac7bf224280c5607e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a92338c30de397c0ac7bf224280c5607e">splice_front</a> (<a class="el" href="classofeli_1_1list.html">list</a> &amp;moved)</td></tr>
<tr class="memdesc:a92338c30de397c0ac7bf224280c5607e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all elements of list <em>moved</em> to the beginnning of list <em>*this</em>. <br/></td></tr>
<tr class="separator:a92338c30de397c0ac7bf224280c5607e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d56b7ca0771d3a768b588239a29f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e9d56b7ca0771d3a768b588239a29f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a6e9d56b7ca0771d3a768b588239a29f3">remove</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6e9d56b7ca0771d3a768b588239a29f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements by their value. <br/></td></tr>
<tr class="separator:a6e9d56b7ca0771d3a768b588239a29f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2982d8f3bf7593929fe6ea3a7ad03fc6"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a2982d8f3bf7593929fe6ea3a7ad03fc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a2982d8f3bf7593929fe6ea3a7ad03fc6">remove_if</a> (UnaryPredicate predicate)</td></tr>
<tr class="separator:a2982d8f3bf7593929fe6ea3a7ad03fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640cb310a5241b411436ff39577706b1"><td class="memTemplParams" colspan="2">template&lt;typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a640cb310a5241b411436ff39577706b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a640cb310a5241b411436ff39577706b1">unique</a> (BinaryPredicate compare)</td></tr>
<tr class="separator:a640cb310a5241b411436ff39577706b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2cd2b67b1e9aab234cfeb647870f96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc2cd2b67b1e9aab234cfeb647870f96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#abc2cd2b67b1e9aab234cfeb647870f96">unique</a> ()</td></tr>
<tr class="memdesc:abc2cd2b67b1e9aab234cfeb647870f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consecutive duplicate values. <br/></td></tr>
<tr class="separator:abc2cd2b67b1e9aab234cfeb647870f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd2eabfec966e211118a90ab9d0a5f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cd2eabfec966e211118a90ab9d0a5f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a3cd2eabfec966e211118a90ab9d0a5f5">reverse</a> ()</td></tr>
<tr class="memdesc:a3cd2eabfec966e211118a90ab9d0a5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the <em>list</em> container. <br/></td></tr>
<tr class="separator:a3cd2eabfec966e211118a90ab9d0a5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeedac18b70d233644d84c7ad3a9a3fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaeedac18b70d233644d84c7ad3a9a3fa"></a>
template&lt;typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:aaeedac18b70d233644d84c7ad3a9a3fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#aaeedac18b70d233644d84c7ad3a9a3fa">sort</a> (BinaryPredicate compare)</td></tr>
<tr class="memdesc:aaeedac18b70d233644d84c7ad3a9a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements with a specified order. The order of equal elements is guaranteed to be preserved (stability). The sorting is performed by merge sort algorithm in <em>O(n log n)</em> in worst-case, where <em>n</em> is the size of the container. It does not require <em>O(n)</em> extra space. <br/></td></tr>
<tr class="separator:aaeedac18b70d233644d84c7ad3a9a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47643ddf2f9ceeb952fb6a8617daf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b47643ddf2f9ceeb952fb6a8617daf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a6b47643ddf2f9ceeb952fb6a8617daf9">sort</a> ()</td></tr>
<tr class="memdesc:a6b47643ddf2f9ceeb952fb6a8617daf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements into ascending order. Calls the function void <a class="el" href="classofeli_1_1list.html#aaeedac18b70d233644d84c7ad3a9a3fa" title="Sorts the elements with a specified order. The order of equal elements is guaranteed to be preserved ...">sort(BinaryPredicate compare)</a> with an object of the class <em>less</em> because parameter by default for a template function is not allowed. <br/></td></tr>
<tr class="separator:a6b47643ddf2f9ceeb952fb6a8617daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e6e91f6df59f3bf1b290a36577e474"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3e6e91f6df59f3bf1b290a36577e474"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ab3e6e91f6df59f3bf1b290a36577e474">empty</a> () const </td></tr>
<tr class="memdesc:ab3e6e91f6df59f3bf1b290a36577e474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the list container is empty, i.e. whether its size is 0. <br/></td></tr>
<tr class="separator:ab3e6e91f6df59f3bf1b290a36577e474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4901f65fa96e300ce11dc75e0760dda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ab4901f65fa96e300ce11dc75e0760dda">size</a> () const </td></tr>
<tr class="separator:ab4901f65fa96e300ce11dc75e0760dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac904f35ef541477948b304f69cdc7384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac904f35ef541477948b304f69cdc7384"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ac904f35ef541477948b304f69cdc7384">display</a> () const </td></tr>
<tr class="memdesc:ac904f35ef541477948b304f69cdc7384"><td class="mdescLeft">&#160;</td><td class="mdescRight">A second way to display a linked list. <br/></td></tr>
<tr class="separator:ac904f35ef541477948b304f69cdc7384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f411dfb78ecfa34f66078a64f7ccb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0f411dfb78ecfa34f66078a64f7ccb6"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ad0f411dfb78ecfa34f66078a64f7ccb6">get_array</a> (int array_length) const </td></tr>
<tr class="memdesc:ad0f411dfb78ecfa34f66078a64f7ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an array with the value of list <em>*this</em>. <br/></td></tr>
<tr class="separator:ad0f411dfb78ecfa34f66078a64f7ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a471424ff8c258a2c00e9246035304cff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a471424ff8c258a2c00e9246035304cff">swap</a> (<a class="el" href="classofeli_1_1list.html">list</a> &amp;list1, <a class="el" href="classofeli_1_1list.html">list</a> &amp;list2)</td></tr>
<tr class="separator:a471424ff8c258a2c00e9246035304cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a7765ecb875543506d04dbd466f754503"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7765ecb875543506d04dbd466f754503"></a>
typedef <a class="el" href="structofeli_1_1list_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a7765ecb875543506d04dbd466f754503">Link</a></td></tr>
<tr class="memdesc:a7765ecb875543506d04dbd466f754503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link is a pointer to a <a class="el" href="structofeli_1_1list_1_1_node.html" title="This structure implements a node of class list. It is composed by an element of type T and a pointer ...">Node</a>. <br/></td></tr>
<tr class="separator:a7765ecb875543506d04dbd466f754503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac969c1209e5bd5b41a8e56e192061aea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac969c1209e5bd5b41a8e56e192061aea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ac969c1209e5bd5b41a8e56e192061aea">alloc_mem_pool</a> ()</td></tr>
<tr class="memdesc:ac969c1209e5bd5b41a8e56e192061aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory pool with a shared linked list. <br/></td></tr>
<tr class="separator:ac969c1209e5bd5b41a8e56e192061aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aed33fb6086a95ce25dd474aef8063661"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed33fb6086a95ce25dd474aef8063661"></a>
<a class="el" href="classofeli_1_1list.html#a7765ecb875543506d04dbd466f754503">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#aed33fb6086a95ce25dd474aef8063661">head</a></td></tr>
<tr class="memdesc:aed33fb6086a95ce25dd474aef8063661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of the list. <br/></td></tr>
<tr class="separator:aed33fb6086a95ce25dd474aef8063661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4751e1b2279d0dcff01b0081d0dcbd19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4751e1b2279d0dcff01b0081d0dcbd19"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a4751e1b2279d0dcff01b0081d0dcbd19">mem_pool_size</a></td></tr>
<tr class="memdesc:a4751e1b2279d0dcff01b0081d0dcbd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes of the memory pool list created by list *this. <br/></td></tr>
<tr class="separator:a4751e1b2279d0dcff01b0081d0dcbd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a8a313f391f6672c8c26ab5d9c7f58396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a313f391f6672c8c26ab5d9c7f58396"></a>
static <a class="el" href="classofeli_1_1list.html#a7765ecb875543506d04dbd466f754503">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a8a313f391f6672c8c26ab5d9c7f58396">mem_head</a></td></tr>
<tr class="memdesc:a8a313f391f6672c8c26ab5d9c7f58396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of the memory pool list which is shared for all lists. <br/></td></tr>
<tr class="separator:a8a313f391f6672c8c26ab5d9c7f58396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4ad2e66a0acf1d35b209f40c861aeae8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ad2e66a0acf1d35b209f40c861aeae8"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a4ad2e66a0acf1d35b209f40c861aeae8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a4ad2e66a0acf1d35b209f40c861aeae8">operator==</a> (const <a class="el" href="classofeli_1_1list.html">list</a>&lt; U &gt; &amp;lhs, const <a class="el" href="classofeli_1_1list.html">list</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4ad2e66a0acf1d35b209f40c861aeae8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Equal</em> <em>to</em> operator overloading. <br/></td></tr>
<tr class="separator:a4ad2e66a0acf1d35b209f40c861aeae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6">operator!=</a> (const <a class="el" href="classofeli_1_1list.html">list</a>&lt; U &gt; &amp;lhs, const <a class="el" href="classofeli_1_1list.html">list</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Not</em> <em>equal</em> <em>to</em> operator overloading. <br/></td></tr>
<tr class="separator:a5f0cc9d1a3a2bcb2450cec7eb0f2dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34eccc5c4d4d114a5f6654becd48c9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab34eccc5c4d4d114a5f6654becd48c9c"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:ab34eccc5c4d4d114a5f6654becd48c9c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classofeli_1_1list.html#ab34eccc5c4d4d114a5f6654becd48c9c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classofeli_1_1list.html">list</a>&lt; U &gt; &amp;displayed)</td></tr>
<tr class="memdesc:ab34eccc5c4d4d114a5f6654becd48c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloading of cout &lt;&lt;. It displays a linked list in the same way as integral-type variable. <br/></td></tr>
<tr class="separator:ab34eccc5c4d4d114a5f6654becd48c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T = int&gt;<br/>
class ofeli::list&lt; T &gt;</h3>

<p>This class implements a singly linked list used by the implementation of Shi and Karl' algorithm. The elements stored are integers by default that correspond of the offset of the level set function buffer. </p>

<p>Definition at line <a class="el" href="linked__list_8hpp_source.html#l00050">50</a> of file <a class="el" href="linked__list_8hpp_source.html">linked_list.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8c619ab7fedd643db5f3894889d91c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns new content to the container, dropping all the elements contained in the container object before the call and replacing them by those specified by the parameters:</p>
<ul>
<li>the new content is the repetition <em>n</em> times of copies of element value. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7fbe8cc25a5c413924db708e47161306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns new content to the container, dropping all the elements contained in the container object before the call and replacing them by those specified by the parameters:</p>
<ul>
<li>the new content is a copy of an array. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2982d8f3bf7593929fe6ea3a7ad03fc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes from the container all the elements for which <em>Predicate</em> <em>predicate</em> returns <code>true</code>. This calls the destructor of these objects and reduces the container size by the number of elements removed. UnaryPredicate <em>predicate</em> can be implemented as any typed expression taking one argument of the same type as the elements container in the <em>list</em> and returning a bool (this may either be a function pointer or an object whose class implements <code>operator()</code>). </p>

</div>
</div>
<a class="anchor" id="ab4901f65fa96e300ce11dc75e0760dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the list without counting the sentinel node. The complexity of this function is in <em>O(n)</em> so if you want to get often the size of the list, you should update the size in a variable after each modification. </p>

</div>
</div>
<a class="anchor" id="af38ebb4b33ce7f5518b78eb1e8ae3464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a> <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::splice_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classofeli_1_1list_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an element <em>moved</em> (of another list or list <em>*this</em>) and inserts at the beginning of list <em>*this</em>. Equivalent to push_front(*it) and it = erase(it) without use of the operators <em>new</em> and <em>delete</em>. Returns a valid iterator, i.e the position of the next element. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classofeli_1_1list_af38ebb4b33ce7f5518b78eb1e8ae3464_icgraph.png" border="0" usemap="#classofeli_1_1list_af38ebb4b33ce7f5518b78eb1e8ae3464_icgraph" alt=""/></div>
<map name="classofeli_1_1list_af38ebb4b33ce7f5518b78eb1e8ae3464_icgraph" id="classofeli_1_1list_af38ebb4b33ce7f5518b78eb1e8ae3464_icgraph">
<area shape="rect" id="node3" href="classofeli_1_1_active_contour.html#a7d9a557b580af708155ff4ab8bbfd73b" title="Outward local movement of the curve for a current point (x,y) of Lout that is switched in Lin..." alt="" coords="165,21,299,62"/><area shape="rect" id="node15" href="classofeli_1_1_active_contour.html#a98af656dfc038e6f03c9e4bb67e39bd0" title="Inward local movement of the curve for a current point (x,y) of Lin that is switched in Lout..." alt="" coords="165,86,299,127"/><area shape="rect" id="node5" href="classofeli_1_1_active_contour.html#a2ab521c583572158549d416ccc755f3a" title="Function called by evolve_one_iteration() for external or data dependant evolution with Fd speed..." alt="" coords="347,5,490,61"/><area shape="rect" id="node11" href="classofeli_1_1_active_contour.html#a7cf8243140d8ef8f72a638e9a1442dc2" title="Function called by evolve_one_iteration() for a curve smoothing or internal evolution with Fint speed..." alt="" coords="347,85,490,141"/><area shape="rect" id="node7" href="classofeli_1_1_active_contour.html#a23013e2eb528bc2fa4e108e928af6f8d" title="Evolves the active contour of one iteration or one step. This function calls the functions do_one_ite..." alt="" coords="539,17,672,58"/><area shape="rect" id="node9" href="classofeli_1_1_active_contour.html#a02cd4d93b90fee487e07f625f337aab1" title="Evolves directly the active contour at the final state, i.e. it evolves while isStopped is not true..." alt="" coords="539,86,672,127"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a471424ff8c258a2c00e9246035304cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classofeli_1_1list.html">list</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classofeli_1_1list.html">list</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges the content of container <em>list1</em> by the content of <em>list2</em>, which is another list object containing elements of the same type. Sizes may differ. Performs it in a constant time without copying. Use this function if you don't have accesss to C++11 (formerly known as C++0x) "void std::swap(T&amp; a, T&amp; b)" version with semantic move. </p>

</div>
</div>
<a class="anchor" id="a640cb310a5241b411436ff39577706b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = int&gt; </div>
<div class="memtemplate">
template&lt;typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classofeli_1_1list.html">ofeli::list</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version accepting a binary predicate, a specific comparison function to determine the "uniqueness" of an element can be specified. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(<em>i,</em>(i-1)) for all pairs of elements (where i is an iterator to an element, starting from the second) and remove i from the list if the predicate returns <code>true</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="linked__list_8hpp_source.html">linked_list.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 14 2013 14:18:08 for Ofeli by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
